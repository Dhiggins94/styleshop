1. to transfer our footer and navbar across the app, we use react router's outlet tag. as the docs describes it the outlet tag allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route. Also should be used in parent route elements to render their child route
 EXAMPLE: instead of having something written for our navbar and footer seperately, we make a layout which holds our navbar and footer and inbetween them we can call whatever page we need (home page, category page, PRODUCT page)


 2.going forward i installed sass and MUI for their icons and better css features since its going to get long later.in the navbar we can use scss to write our items inside the parent.  we remove the underlines, text decoration,custom colors by making a scss file for our "app" for app.js and give the values of color inheret and text decoration none

3. When creating the react slider from scratch we need to set up a useState(0) for the currentSlide and 2 functions symbolizing the previous slide and the next Slide that'll follow. We made a teary operator for the 2 functions that if the slide is at 0 or 2 to plus or minus 1 so the first slide and last slide will loop into each other if the buttons are pressed. Afterwards to make the movement work we need to go to our div that contains the images(classname container) and make a style sheet directly in the container using transform: translateX which moves things on its X axis, with our current slide presenting 0, it moves 0,100,200 on the X axis which gets us our 3 sliding images. Paired with the container.scss we set a transition for all sides for 1 second with ease and now we have a working react slider.

4.using strapi as our backend, we are able to store our clothes data and create connections via relational data modeling all inside strapi. using things like media library to store images. some fields such as enumeration field allows the user to create options and the value of said field can be one of those options

5.to connect our strapi backend (we're using a mysql database) to our react project, we need to create a dot.env file with our strapi token and localhost url, and upload url. afterwards we create a useEffect using headers and async awaits to grab our strapi app url and token key from our dot.env file into our featuredProducts to finally grab our data. To actually see our data we had to go to our card element and use our dot.env file to pick up our react app upload url (the source of our images) and grabbed them using our "item" prop along with our prices and titles of the products.

6. next we need to fetch out the items from the strapi backend using their built in documentation for filtering (ex: GET /api/:pluralApiId?filters[field][operator]=value)
link: https://docs.strapi.io/dev-docs/api/rest/filters-locale-publication.  for me, the field i need to fill in is the "type" and the operator would be things like equal,less than greater than etc. since we want to declutter the featuredProducts.jsx, we created an hooks folder and a file called useFetch.js to hold our useEffect in AND a file called makeRequest.js which would hold our tokens and baseURL. inside of our useFetch.js we add 3 sets of useState for data(the data we're going to fetch with the help of our makeRequest.js), loading(which assists in loading our state between calls, its also gets used a boolean with the data map in featuredProducts) an error which is used to tell us something went wrong with our data inside the tryCatch block. Afterwards we return the 3 states, export useFetch & import the infomation to our featuredProducts.jsx.  inside our featuredProducts, we set our 3 states as our useFetch hook and have the data inside the useFetch be the filtering routes for our strapi API. we take our error state and wrap it around our card data mapping so we can see an error message in case something went wrong, we also place our loading state inside the data mapping so that it'll either show the words "loading" or our actual data if its present, and lastly data...which is already present inside the featuredProducts so nothing changes.

7. next we start filtering our data so certain information goes in certain categories.